## _Краткий план выполнения работы_
* Создадим основной класс `ZooCoordinator`, который будет координировать работу сервисов.
* Напишем интерфейсы `IAlive` и `IInventory` в папке Interfaces, так как такое решение было предложено в задании.
* Реализуем классы `Animal`, `Herbivore`, `Predator`, `Monkey`, `Rabbit`, `Tiger`, `Wolf`.\
Неочевидные дополнения:
  - животных есть метод `setNumber(int)`, поскольку нумерацией будет заниматься `Storage`;
  - В классе `Animal` есть статические методы `isPredator(int)` и `isHerbivore(int)` для работы с перечислением `AnimalTypes`;
  - По-приколу был добавлен метод `describe()` (у волка, очевидно, лучшее описание);
  - Класс `Herbivore` заменяет класс `Herbo`.
* Объявим интерфейс `VetClinic`, описывающий необходимое для зоопарка поведение клиники. Она должна принять животное или отвергнуть его. Конкретная реализация не указана, поэтому 
всё будет решать рандом. Создадим реализацию `RandomVet` этого интерфейса с публичным методом `bool checkHealth(Animal)`, который с вероятностью 5% будет возвращать `false`, иначе `true`.
* Заказчик предлагает создать классы `Thing`, `Table`, `Computer`, значит их тоже сделаем. Им также пришлось добавить метод `setNumber(int)`, потому что нумерацией занимается `Storage`.
* Требуется сделать консольное приложение, функционал которого я опишу ниже.
* Написать readme-файл с пояснениями идей решения. Кажется есть.
* Создать инструкции по запуску. Я лично в IntellijIDEA запускаю класс `org.Zoo.start`. 
### Описание функционала консольного приложения
Работа с консолью осуществляется следующим образом:\
Есть интерфейс `ConsoleInterface`, в котором можно установить **процессор** (опишу ниже), запросить версию (потенциально полезно), а также превратить входные данные в **запрос** (опишу ниже). 
#### Процессор `Processor`
Реализация находится в классе `MyProcessor`. Представляет собой конечный автомат для работы со структурой CommandToken. Он превращает **нетерминальные команды** в терминальные (**запросы**), проводя токены через необходимые состояния.
Процессор умеет проверять, является ли токен терминальным.
#### Запрос `RequestInterface`
Запрос по своей сути является терминальной командой, ведь когда `Processor` готов однозначно идентифицировать запрос, он прекращает чтение из консоли и отправляет в класс `MyConsole` собранный запрос для передачи в `ZooCoordinator`. После успешного исполнения запроса, координатор начинает ждать новый запрос. Таким образом, координатор завершает работу с консолью после ошибки во время выполнения запроса или после успешного выполнения запроса `QuitRequest`.\
Класс, работающий со структурой `RequestableType`, содержащей в себе объекты `Storage` и `VetClinic`, что позволяет осуществлять любые запросы, требуемые в задании.
Каждый запрос объявлен в отдельном классе, чтобы минимизировать количество страшных конструкторов. Для упрощения написания кода был создан шаблонный абстрактный класс `Request`, реализующий все необходимые конструкторы и объявляющий необходимые поля.\
Для выполнения задания были созданы запросы для:
1. Добавления животного в зоопарк (процесс добавления включает ветеринарную проверку и нумерацию);
2. Добавления предмета на склад (процесс добавления включает нумерацию);
3. Печати в консоль отчёта о количестве животных и потребляемом ими количестве еды;
4. Печати в консоль информации , доступных для отправки в контактный зоопарк (доброта не меньше 5);
5. Печати в консоль всего содержимого зоопарка;
6. Завершения работы в консоли. Добавлен мной, поскольку иначе приложение можно было бы завершить только аварийно.
#### Нетерминальная команда `NonTerminalCommand`
Класс, результатом выполнения которого является `CommandToken`, а не `Request`. То есть после выполнения нетерминальной команды нужно выполнить ещё хотя бы одну нетерминальную команду для составления запроса.\
Поскольку `Processor` обязан вернуть `MyConsole` объект типа `Request`, то он должен исполнять нетерминальные команды до тех пор, пока они не превратятся в запрос. Такую логику можно очень легко реализовать в цикле `while`, исполняющемся пока токен нетерминальный. Для этого в процессор был добавлен метод проверки токена на терминальность `boolean isTerminal(CommandToken)`.\
Для реализации удобной и понятной для пользователя системы были реализованы следующие нетерминальные команды:
1. Выбрать команду. Является начальным состоянием, в него возвращаются в случае ошибки в других нетерминальных командах;
2. Выбрать вид животного;
3. Выбрать параметры животного;
4. Выбрать вид предмет;
5. Показать существующие команды. После своего выполнения переводит в начальное состояние.

Замечание: из любого нетерминального состояния, не являющегося начальным, можно вернуться в начальное, написав команду `abort` (это нужно отдельно реализовывать в новых нетерминальных командах).
## _Места применения принципов SOLID_
### Single Responsibility
Класс `ZooCoordinator` ответственный за координацию высокоуровневых классов между собой.\
Классы `Animal`, `Herbivore`, `Predator` отвечают за работу с данными групп животных.\
Классы `Monkey`, `Rabbit`, `Tiger`, `Wolf` отвечают за работу с данными конкретных животных.\
Классы внутри `org.Zoo.Console` также узкоспециализированные.\
`org.Zoo.Storages` содержит классы, ответственные за хранение животных и предметов отдельно.\
Класс `RandomVet` проверяет здоровье животного.
### Open/Close
В папках `org.Zoo.Console`, `org.Zoo.Storages`, `org.Zoo.Vet` находятся интерфейсы, которые можно имплементировать своими классами. То есть можно написать, например, свою реализацию ветеринарной клиники, не меняя моего кода.
### Liskov
Наследование не абстрактных классов проводилось только в папке `org.Zoo.Items`, когда `Computer` и `Table` наследовались от `Thing`. По идее `Thing` сам по себе нигде использоваться не должен, но в условии это чётко не сказано, поэтому я решил оставить возможность создавать объект типа `Thing`.\
От абстрактных классов наследовался часто, во всех случаях функционал родительского класса только расширялся.
### Interface Segregation
Старался создавать интерфейс для каждой обобщающей абстракции, которую мог заметить. Таким образом получились интерфейсы `NonTerminalCommand`, `Processor`, `AnimalStorage`, `ItemStorage`, `VetClinic`, `ConsoleInterface`. 
### Dependency Inversion
Все мои высокоуровневые модули, а именно `ZooCoordinator`, `MyStorage`, `MyConsole`, `RandomVet` связаны между собой через интерфейсы.
## _Места покрытия тестами_
1. `RandomVet` должен допускать около 95% всех данных ему животных, мой тест проверяет, что допускается 94-96% из миллиона животных.
2.  В `MyStorage` тестами покрыты все его методы, кроме `describe` (используется в других методах) и `version` (выводит строковый литерал).
3. `MyConsole` содержит два интересных для тестирования метода: `setProcessor()` и `readInput()`, второй полностью зависит от класса `Processor`, поэтому тестировать будем только первый.
## Применение DI контейнера 
Все необходимые для работы моего приложения классы объявлены компонентами, в `ZooCoordinator` с помощью `@Autowired` подключены необходимые для его работы классы. Также через @Autowired в `MyStorage` подключены `MyItemStorage` и `MyAnimalStorage`, а в `MyConsole` подключен `MyProcessor`.
## _Объяснение формата ввода/вывода_
Постарался сделать всё достаточно интерактивно, чтобы можно было легко разобраться.\
Все ключевые слова переводятся в lowercase, поэтому можно писать заглавными буквами (или вперемешку).\
Возможные названия животных (опять-таки всё в итоге сведётся в lowercase):
* `Обезьяна` или `Monkey`;
* `Заяц` или `Rabbit`;
* `Тигр` или `Tiger`;
* `Волк` или `Wolf`.

Возможные названия предметов:
* `Компьютер` или `Computer`;
* `Стол` или `Table`.