## _Краткий план выполнения работы_
* Создадим основной класс `Zoo` (он же класс, описывающий зоопарк).
* Напишем интерфейсы `IAlive` и `IInventory` в папке Interfaces, так как такое решение было предложено в задании.
* Реализуем классы `Animal`, `Herbivore`, `Predator`, `Monkey`, `Rabbit`, `Tiger`, `Wolf`.
Класс `Herbivore` заменяет класс `Herbo`.
* В тз требуется сделать ассоциацию класса `Zoo` с классом ветеринарная клиника. Такого класса у нас ещё нет, 
поэтому нужно его реализовать.
* Реализуем класс `Vet`. Он должен принять животное или отвергнуть его. Конкретная реализация не указана, поэтому 
всё будет решать рандом. Сделаем публичный метод `bool checkHealth(Animal)`, который с вероятностью 5% будет возвращать `false`, иначе `true`.
* Заказчик предлагает создать классы `Thing`, `Table`, `Computer`, значит их тоже сделаем.
* Требуется сделать консольное приложение, функционал которого я опишу ниже.
* Написать readme-файл с пояснениями идей решения.
* Создать инструкции по запуску.
### Описание функционала консольного приложения
Назначим класс `Console` для осуществления взаимодействия между пользователем и классом `Zoo`.  В классе `Console` нам понадобятся классы `Input` и `Output`. 
* Считывать информацию о животном из консоли.
## _Идеи во время выполнения_
Зоопарк должен иметь в себе ссылку на класс консоли, поскольку зоопарк не должен уметь писать в консоль, иначе получим нарушение принципа Single Responsibility.\
Консоль должна иметь в себе ссылку на зоопарк, чтобы отправлять ему запросы (например, на добавление животных), которые зоопарк будет перенаправлять сначала в ветеринарную клинику, а потом в хранилище.

## _Места применения принципов SOLID_
### Single Responsibility
Класс `ZooCoordinator` ответственный за координацию высокоуровневых классов между собой.\
Классы `Animal`, `Herbivore`, `Predator` отвечают за работу с данными групп животных.\
Классы `Monkey`, `Rabbit`, `Tiger`, `Wolf` отвечают за работу с данными конкретных животных.\
Классы внутри `org.Zoo.Console` также узкоспециализированные.\
`org.Zoo.Storages` содержат классы, ответственные за хранение животных и предметов отдельно.\
Класс `RandomVet` проверяет здоровье животного.
### Open/Close
В папках `org.Zoo.Console`, `org.Zoo.Storages`, `org.Zoo.Vet` находятся интерфейсы, которые можно имплементировать своими классами. То есть можно написать, например, свою реализацию ветеринарной клиники, не меняя моего кода.
### Liskov
Наследование не абстрактных классов проводилось только в папке `org.Zoo.Items`, когда `Computer` и `Table` наследовались от `Thing`. По идее `Thing` сам по себе нигде использоваться не должен, но в условии это чётко не сказано, поэтому я решил оставить возможность создавать объект типа `Thing`.
### Interface Segregation
Старался создавать интерфейс для каждой обобщающей абстракции, которую мог заметить. Таким образом получились интерфейсы `Command`, `Processor`, `AnimalStorage`, `ItemStorage`, `VetClinic`. 
### Dependency Inversion
Все мои высокоуровневые модули, а именно `Zoo`, `MyStorage`, `ConsoleApp`, `RandomVet` связаны между собой через интерфейсы.
## _Места покрытия тестами_
Пока что ничего не покрыто, идеи для покрытия:
1. Сразу напрашивается протестировать класс `Vet`. Он работает на генераторе случайных чисел, поэтому стоит провести большое количество запусков метода `checkHealth()` и проверить, что частота выдачи `false` действительно около 5%.

## Применение DI контейнера 
Все необходимые для работы моего приложения классы объявлены компонентами, в `ZooCoordinator` с помощью `@Autowired` подключены необходимые для его работы классы.
## _Объяснение формата ввода/вывода_